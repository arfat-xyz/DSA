# Fibonacci number best case is `Iterative Fibonacci with Temp Variable`

---

## âœ… 1. **Recursive Fibonacci (Naive)**

```js
var fib = function (n) {
  if (n === 0 || n === 1) return n;
  return fib(n - 1) + fib(n - 2);
};
```

### ğŸ” How It Works:

- Recursively calls `fib(n-1)` and `fib(n-2)` until it hits the base case.
- This directly follows the mathematical definition of Fibonacci.

### âš ï¸ Time & Space Complexity:

- **Time**: `O(2^n)` â€” Exponential growth due to repeated calculations.
- **Space**: `O(n)` â€” Due to call stack from recursion depth.

### ğŸš« Downsides:

- Extremely slow for large `n` (e.g. `fib(40)` takes noticeable time).
- Lots of repeated computation (`fib(30)` may compute `fib(20)` dozens of times).

---

## âœ… 2. **Iterative Fibonacci with Temp Variable**

```js
var fib = function (n) {
  if (n <= 1) {
    return n;
  }
  let n1 = 0,
    n2 = 1;
  for (let i = 2; i <= n; i++) {
    let temp = n2;
    n2 = n1 + temp;
    n1 = temp;
  }
  return n2;
};
```

### ğŸ” How It Works:

- Uses a simple loop to update two variables (`n1` and `n2`) iteratively.
- Avoids recursion entirely.

### âœ… Time & Space Complexity:

- **Time**: `O(n)`
- **Space**: `O(1)` â€” Constant space, no recursion or extra data structures.

### âœ… Benefits:

- Fast and memory-efficient.
- Ideal for most practical use cases.

---

## âœ… 3. **Iterative Fibonacci Using Destructuring**

```js
var fib = function (n) {
  if (n <= 1) {
    return n;
  }
  let n1 = 0,
    n2 = 1;
  for (let i = 1; i < n; i++) {
    [n1, n2] = [n2, n1 + n2];
  }
  return n2;
};
```

### ğŸ” How It Works:

- Same logic as the previous loop, but uses **array destructuring** for cleaner swapping.

### âœ… Time & Space Complexity:

- **Time**: `O(n)`
- **Space**: `O(1)`

### âš ï¸ Minor Note:

- Slightly slower than the `temp` version due to destructuring overhead (microseconds).
- Still a solid and elegant solution.

---

## âœ… 4. **Recursive Fibonacci with Memoization (Map)**

```js
var fib = function (n) {
  const map = new Map([
    [1, 1],
    [0, 0],
    [2, 1],
    [3, 2],
  ]);

  const recursive = (n1) => {
    if (!map.has(n1)) {
      map.set(n1, recursive(n1 - 1) + recursive(n1 - 2));
    }
    return map.get(n1);
  };
  return recursive(n);
};
```

### ğŸ” How It Works:

- Recursively calculates Fibonacci numbers but **stores** previously computed values in a `Map`.
- This avoids recomputing values (a big improvement over naive recursion).

### âœ… Time & Space Complexity:

- **Time**: `O(n)`
- **Space**: `O(n)` â€” Because it stores up to `n` values in the `Map`.

### âœ… Benefits:

- Elegant mix of recursion + optimization.
- Ideal when you're already working with recursion or want a more functional approach.

---

## ğŸ† **Which One Is Best?**

| Version                   | Time Complexity | Space Complexity | Speed              | Readability | Recommended Use                 |
| ------------------------- | --------------- | ---------------- | ------------------ | ----------- | ------------------------------- |
| Recursive (Naive)         | âŒ O(2^n)       | O(n)             | âŒ Slow            | âœ… High     | For teaching/concept only       |
| Iterative (with temp)     | âœ… O(n)         | âœ… O(1)          | âœ… Fast            | âœ… High     | âœ… Best for real-world use      |
| Iterative (destructuring) | âœ… O(n)         | âœ… O(1)          | âš ï¸ Slightly slower | âœ… Clean    | Good if you like concise code   |
| Memoized Recursive (Map)  | âœ… O(n)         | âš ï¸ O(n)          | âœ… Fast            | âœ… High     | Great if recursion is preferred |

---

### âœ… Final Verdict:

For **performance-critical or production code**, go with:

```js
// Best all-around:
var fib = function (n) {
  if (n <= 1) {
    return n;
  }
  let n1 = 0,
    n2 = 1;
  for (let i = 2; i <= n; i++) {
    let temp = n2;
    n2 = n1 + temp;
    n1 = temp;
  }
  return n2;
};
```
